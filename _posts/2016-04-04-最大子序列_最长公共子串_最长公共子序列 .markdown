---
layout:     post
title:      "最大子序列&最长公共子串&最长公共子序列 "
subtitle:   " "
date:       2016-04-04 08:00:00
author:     "Johnnwen"
header-img: "img/post-bg-kuaidi.jpg"
catalog:    true
tags:
    - 字符串
    - 动态规划
    - LCS
    - DP
    - 数据结构
    - c++
    
---

###  1、最大子序列和问题

```
class Solution {
public:
    int max_sub(vector<int>& vector)
    {
        int max=0,temp_sum=0;
        for(int i=0;i<vector.size();i++)
        {
            temp_sum+=vector[i];
            if(temp_sum>max)
                max=temp_sum;
            else if(temp_sum<0)
                temp_sum=0;
        }
        return max;
    }
};
```


###  2、最长公共子串

```
#define MAX 1000
int res[MAX][MAX];


class Solution {
public:
    int  lcString(string str1,string str2) {
        int i = 0, j = 0;
        int maxlengh = 0;
        for(i = 0; i < str1.size(); ++i)
        {
            for(j = 0; j < str2.size(); ++j) //res[i][j]为最长公共子串的长度
            {
                if(str1[i] == str2[j]){
                    if(res[i][j] == 0)
                        res[i + 1][j + 1] = 1;
                    else
                        res[i + 1][j + 1] = res[i][j] + 1;
                    maxlengh = max(maxlengh,res[i + 1][j + 1]);
                }
            }
        }
        
        return maxlengh;
    }
};
```

###  3、最长公共子序列

##### 代码

```

#define MAX 1000
int res[MAX][MAX];

class Solution {
public:
    int  lcSubsequence(string str1,string str2) {
        int i = 0, j = 0;
        for(i = 0; i < str1.size(); ++i)
        {
            for(j = 0; j < str2.size(); ++j) //res[i][j]为最长公共子序列的长度
            {
                if(str1[i] != str2[j])
                    res[i + 1][j + 1] = max(res[i + 1][j], res[i][j + 1]);
                else
                    res[i + 1][j + 1] = res[i][j] + 1;
            }
        }

        return res[i][j];
        
    }
};
```


## 扩展

## 1、回文字符串

##### 题意

回文字符串，即从左到右读和从右到左读是完全一样的字符串，比如"asdsa"。当然，给定一个字符串，可在任意位置添加字符，现在要求最少再添加几个字符，可以使这个字符串成为回文字符串。

##### 思路分析

最长公共子序列的变种，将原序列str倒置后得到tmp。求出最长公共子序列的长度，则公共子序列就是回文字串，剩下的就是没有匹配字符的个数。用字符串的总长度减去最长公共子序列的长度，即得到需要添加的字符数量。

##### 代码

```

#define MAX 1000
int res[MAX][MAX];

class Solution {
public:
    int  palindromeString(string str) {
        int i = 0, j = 0;
        string tmp;
        tmp = str;
        reverse(tmp.begin(), tmp.end()); //倒置
        for(i = 0; i < str.size(); ++i)
        {
            for(j = 0; j < tmp.size(); ++j) //res[i][j]为最长公共子序列的长度
            {
                if(str[i] != tmp[j])
                    res[i + 1][j + 1] = max(res[i + 1][j], res[i][j + 1]);
                else
                    res[i + 1][j + 1] = res[i][j] + 1;
            }
        }

        return (int)(str.size() - res[i][j]);
        
    }
};
```

## 2、最长回文字符串

#### 题意

输出字符串中的最长回文字符串

#### 例如

输入字符串 "google”，由于该字符串里最长的对称子字符串是 "goog”，因此输出4。

#### 分析

最长公共子串的变种，将原序列str倒置后得到tmp。求出最长公共子串的长度，则公共子串的长度就是回文字串的长度。

#### 代码

```

class Solution {
public:
    int  palindromeString(string str) {
        int i = 0, j = 0,maxlengh=0;
        string tmp;
        tmp = str;
        reverse(tmp.begin(), tmp.end()); //倒置
        for(i = 0; i < str.size(); ++i)
        {
            for(j = 0; j < tmp.size(); ++j) //res[i][j]为最长公共子序列的长度
            {
                if(str[i] == tmp[j]){
                    if(res[i][j] == 0)
                        res[i + 1][j + 1] = 1;
                    else
                        res[i + 1][j + 1] = res[i][j] + 1;
                    maxlengh = max(maxlengh,res[i + 1][j + 1]);
                }
            }
        }
        
        return maxlengh;
        
    }
};
```


