<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wangyw Blog</title>
    <description>Java Android</description>
    <link>http://johnnwen.github.io/</link>
    <atom:link href="http://johnnwen.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 01 Apr 2016 11:36:22 +0800</pubDate>
    <lastBuildDate>Fri, 01 Apr 2016 11:36:22 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>归并排序</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;算法简介&lt;/h2&gt;

&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;归并排序的基本思想&lt;/h2&gt;

&lt;p&gt;将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。
综上可知：&lt;/p&gt;

&lt;p&gt;归并排序其实要做两件事：&lt;br /&gt;
（1）“分解”——将序列每次折半划分。&lt;br /&gt;
（2）“合并”——将划分后的序列段两两合并后排序。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实现代码&lt;/h2&gt;
&lt;p&gt;传入merge函数数组，以及分段标识low、mid和high&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void merge_my(int arr[],int low,int mid,int high){
    int temp = mid;
    int low_temp = low;
    int index = 0;
    int *mergeArray = new int[high -  low +1];
    while (low&amp;lt;mid &amp;amp;&amp;amp; temp&amp;lt;=high) {
        if (arr[low]&amp;lt;=arr[temp]) {
            mergeArray[index] = arr[low];
            index++;
            low++;
        }else{
            mergeArray[index] = arr[temp];
            temp++;
            index++;
        }
    }
    while (low&amp;lt;mid) {
        mergeArray[index] = arr[low];
        index++;
        low++;
    }
    while (temp&amp;lt;=high) {
        mergeArray[index] = arr[temp];
        temp++;
        index++;
    }

    for (index = 0; low_temp&amp;lt;=high; low_temp++,index++) {
        arr[low_temp] = mergeArray[index];

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对数组进行分块&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void mergeSort(int arr[],int gap,int length){
    int i =0;
    for (i=0; i+ 2*gap-1&amp;lt;length; i = i + 2*gap) {
        merge_my(arr, i, i + gap, i + 2*gap -1);
    }

    if (i + gap - 1 &amp;lt;length) {
        merge_my(arr, i, i + gap, length-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;调用方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, const char * argv[]) {
    int arr[8] = {4,2,1,5,7,3,9,6};
    for (int gap =1; gap &amp;lt; 8; gap = 2*gap) {
        mergeSort(arr, gap, 8);
    }
    for (int i = 0; i&amp;lt;8; i++) {
        cout&amp;lt;&amp;lt;arr[i]&amp;lt;&amp;lt;endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 20:00:00 +0800</pubDate>
        <link>http://johnnwen.github.io/2016/03/28/merge/</link>
        <guid isPermaLink="true">http://johnnwen.github.io/2016/03/28/merge/</guid>
        
        <category>算法</category>
        
        <category>排序</category>
        
        
      </item>
    
      <item>
        <title>堆排序</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;算法简介&lt;/h2&gt;

&lt;p&gt;堆是一棵顺序存储的完全二叉树。
其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。
其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。
举例来说，对于n个元素的序列{R0, R1, … , Rn}当且仅当满足下列关系之一时，称之为堆：&lt;br /&gt;
      (1) Ri &amp;lt;= R2i+1 且 Ri &amp;lt;= R2i+2 (小根堆)&lt;br /&gt;
      (2) Ri &amp;gt;= R2i+1 且 Ri &amp;gt;= R2i+2 (大根堆)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/heap.jpg&quot; alt=&quot;堆&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;归并排序的基本思想&lt;/h2&gt;

&lt;p&gt;使用原数组构造大顶堆，然后将对顶数据节点与array[n-1]进行互换，之后将新数组重新构造。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实现代码&lt;/h2&gt;
&lt;p&gt;对应节点与子数进行比较&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heapAdjust(int arr[],int parent,int length){
    int key = arr[parent];
    int child = parent * 2 + 1;
    while (child&amp;lt;length) {
        if (child + 1 &amp;lt; length  &amp;amp;&amp;amp; arr[child+1]&amp;gt;arr[child]) {
            child++;
        }

        if(key &amp;gt; arr[child])break;
        arr[parent] = arr[child];
        parent = child;
        child = child*2 + 1;

    }
    arr[parent] = key;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;初始进行遍历&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void heapSort(int arr[],int length){
    int mid = length /2;
    for (int i=mid; i&amp;gt;=0; i--) {
        heapAdjust(arr, i, length);
    }

    for (int j=length-1;j&amp;gt;=0; j--) {
        int temp = arr[0];
        arr[0] = arr[j];
        arr[j]=temp;

        heapAdjust(arr, 0, j);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;调用方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HeapSort(){
        size_leng = 5;
        arr_lala = new int[size_leng];
        for (int p=0; p&amp;lt;size_leng; p++) {
            arr_lala[p] = 10 - p;
        }

        heapSort(arr_lala,size_leng);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 20:00:00 +0800</pubDate>
        <link>http://johnnwen.github.io/2016/03/28/heapSort/</link>
        <guid isPermaLink="true">http://johnnwen.github.io/2016/03/28/heapSort/</guid>
        
        <category>算法</category>
        
        <category>排序</category>
        
        
      </item>
    
  </channel>
</rss>
